/***********************************************************************/
/*                                                                     */
/*  FILE        :charge.c                                              */
/*  DATE        :Mon, Mar 07, 2016                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :25                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

#include <stdio.h>
#include "sfr_r825.h"


#include "define.h"

unsigned char data_num;
unsigned char status;
unsigned char old_status=0xff;
unsigned char old_data_num;
unsigned char old_pc;
char sw_data;

#include "function.h"
#include "function_i2c.h"
#include "function_serial.h"
#include "function_da.h"
#include "function_charge.h"



void main(void);



void main(void)
{
	char tmp[1];
	
	init();

	status = MENU_CHG;
	mode = MODE_MENU;
	seq_mode = 0;

	display_menu(status);

	serial1_send("msg: wake up\r\n\r\n");

//	traic = 0b00000101;		//i2c割り込みレベル5
//	asm("FSET I");			//割り込み許可
	while(1)
	{

		sw_data = check_sw();
		setting_change();
		status_change();
		if(old_status != status || old_data_num != data_num || old_pc != pc)
		{
			old_status = status;
			old_data_num = data_num;
			old_pc = pc;
			display_menu(status);
		}
		wait_10msec();


	}
}



#pragma	INTERRUPT timer_test
void timer_test(void)
{
	char tmp[16];
	unsigned int v_tmp;
	unsigned int c_tmp;
	char convert_8to10[8] = {0,1,3,4,5,6,8,9};
	int i;
	unsigned long cap_tmp;
	
	//時間表示

	tmp[0]=(time_cnt/8/10000)%10 + '0';
	tmp[1]=(time_cnt/8/1000)%10 + '0';
	tmp[2]=(time_cnt/8/100)%10 + '0';
	tmp[3]=(time_cnt/8/10)%10 + '0';
	tmp[4]=(time_cnt/8)%10 + '0';
	tmp[5]='.';
	tmp[6]=convert_8to10[(time_cnt)%8] + '0';
	tmp[7]='\0';
	serial1_send_n(tmp, 7);
	serial1_send_n(", ", 2);
		
	sw_data = check_sw();
	if(mode == MODE_CHG)
	{
		//電流変更
	 	if(setting_mode == EDIT_MODE)
		{
			if((sw_data & SW_UP) != 0)
			{
				switch(setting_place)
				{
					case 0:
						if(current <= 2560)
						{ //current<=6A
							current_char[0] ++;
						}
						break;
					case 1:
						if(current <= 2944)
						{ //current<=6.9A
							if(current_char[1]=='9')
							{
								current_char[0] ++;
								current_char[1] = '0';
							}else
							{
								current_char[1] ++;
							}
						}
						break;
					case 2:
						if(current <= 2982)
						{ //current<=6.99A
							if(current_char[2]=='9')
							{
								if(current_char[1]=='9')
								{
									current_char[0] ++;
									current_char[1] = '0';
								}else
								{
									current_char[1] ++;
								}
								current_char[2] = '0';								
							}else
							{
								current_char[2] ++;
							}
						}
						break;
					default:
						break;
				}
				current_char_to_current();
				da_out(0,current);
				voltage_max=0;
				if(peak_delay==0)
				{
					peak_delay = 3;
				}
/*				tmp[0]=current_char[0];
				tmp[1]='.';
				tmp[2]=current_char[1];
				tmp[3]=current_char[2];
				lcd_display(0xC0, tmp, 4);*/
//				lcd_set_address(0xC0+setting_place);
			}else if((sw_data & SW_DOWN) != 0)
			{
				switch(setting_place)
				{
					case 0:
						if(current >= 427)
						{ //current>=1A
							current_char[0] --;
						}
						break;
					case 1:
						if(current >= 43)
						{ //current>=0.1A
							if(current_char[1]=='0')
							{
								current_char[0] --;
								current_char[1] = '9';
							}else
							{
								current_char[1] --;
							}
						}
						break;
					case 2:
						if(current >= 4)
						{ //current<=0.01A
							if(current_char[2]=='0')
							{
								if(current_char[1]=='0')
								{
									current_char[0] --;
									current_char[1] = '9';
								}else{
									current_char[1] --;
								}
								current_char[2] = '9';								
							}else
							{
								current_char[2] --;
							}
						}
						break;
					default:
						break;
				}
				current_char_to_current();
				da_out(0,current);
				voltage_max=0;
				if(peak_delay==0)
				{
					peak_delay = 3;
				}
/*				tmp[0]=current_char[0];
				tmp[1]='.';
				tmp[2]=current_char[1];
				tmp[3]=current_char[2];
				lcd_display(0xC0, tmp, 4);*/
//				lcd_set_address(0xC0+setting_place);
			}else if((sw_data & SW_RIGHT) != 0)
			{
				if(setting_place == 2)
				{
					edit_mode_off();
				}else
				{
					setting_place++;
/*					if(setting_place==0)
					{
						lcd_set_address(0xC0);
					}else
					{
						lcd_set_address(0xC0+setting_place);
					}*/
						
				}
			}
		}else
		{
			if((sw_data & SW_RIGHT) != 0)
			{
				edit_mode_on();
			}
		}
		
		
		//電流表示
		tmp[0]=current_char[0];
		tmp[1]='.';
		tmp[2]=current_char[1];
		tmp[3]=current_char[2];
		tmp[4]='A';
		tmp[5]='\0';
		lcd_display(0xC0, tmp, 5);
		lcd_set_address(0xC0+setting_place);
		
		serial1_send_n(tmp, 4);
		serial1_send_n(", ", 2);

		//ad 電圧読み込み
		voltage_monitor = ad_read();

		if((voltage_max<voltage_monitor) && (peak_delay == 0))
		{
			voltage_max=voltage_monitor;
		}

		//ad 電流読み込み
		current_monitor = ad_read_internal(3);
		c_tmp = current_monitor * 125 / 32;

		//容量更新
		capacity_monitor += current;

//表示
//電圧に変換
//アンプの倍率1/4
//x/(65536-1)*2.048*4
		v_tmp = voltage_monitor;
		tmp[0] = v_tmp / 4000;
		v_tmp = v_tmp % 4000;
		tmp[2] = v_tmp / 400;
		v_tmp = v_tmp % 400;
		tmp[3] = v_tmp / 40;
		v_tmp = v_tmp % 40;
		tmp[4] = v_tmp / 4;
		tmp[5] = convert_4to10[ v_tmp % 4 ];

		for(i=0;i<6;i++)
		{
		  tmp[i] += 48;
		}
		tmp[1] = '.';
		tmp[6] = 'V';
		tmp[7] = ' ';
		
		serial1_send_n(tmp, 6);
		serial1_send_n(", ", 2);
		
		//容量
		cap_tmp=capacity_monitor / 3 / 4096;
		tmp[8] = (cap_tmp / 1000) % 10+'0';
		tmp[9] = (cap_tmp / 100) % 10+'0';
		tmp[10] = (cap_tmp / 10) % 10+'0';
		tmp[11] = cap_tmp % 10+'0';
		tmp[12] = 'm';
		tmp[13] = 'A';
		tmp[14] = 'h';
		tmp[15] = ' ';
		lcd_display(0x80, tmp, 16);

		serial1_send_n(&tmp[8], 4);
		serial1_send_n(", ", 2);

		wait_50usec();


		//電流モニタ
		tmp[0] = c_tmp / 100 + '0';
		tmp[1] = '.';
		tmp[2] = (c_tmp / 10) % 10 + '0';
		tmp[3] = c_tmp % 10 + '0';
		tmp[4] = 'A';
		tmp[5] = '\0';
		

		lcd_display(0xC8, tmp, 8);
		serial1_send_n(tmp, 4);
		serial1_send_n(", \r\n", 4);

		if(setting_place == 0)
		{
			lcd_set_address(0xC0+setting_place);
		}else{
			lcd_set_address(0xC0+setting_place+1);
		}
		//ピークディレイ更新
		if(peak_delay > 0)
		{
			peak_delay --;
		}


//		終了判定
//			左ボタン


		if((sw_data & SW_LEFT) != 0)
		{
			serial1_send("msg: end@cancel\r\n");
			end_flag = 0b10000000;
			goto end_return;
		}else if((peak_delay == 0) && (voltage_max > voltage_monitor) && ((voltage_max - voltage_monitor) >= delta_peak))
		{
		//Δピーク　ピークディレイ時無視
			serial1_send("msg: end@peak\r\n");
			end_flag = 0b01000000;
			goto end_return;
		}else if((current<=stop_current) && (cv_trickle_mode == 1))
		{
			serial1_send("msg: end@cur\r\n");
			end_flag = 0b00010000;
			goto end_return;
		}else if((voltage_monitor>voltage) && (current>stop_current) && (cv_trickle_mode != 0))
		{
			voltage_max=0;
			if(current > current - dec_speed-1)
			{
				current = current - dec_speed-1;
			}else{
				current = 0;
			}
			da_out(0, current);
			wait_50usec();
			current_to_current_char();

		}else if((voltage_monitor>=voltage) && (cv_trickle_mode == 0))
		{
			serial1_send("msg: end@volt\r\n");
			end_flag = 0b00100000;
			goto end_return;
		}else if(capacity_monitor>=capacity)
		{
			serial1_send("msg: end@cap\r\n");
			end_flag = 0b00001000;
			goto end_return;
		}
		

		
	}else if(mode == MODE_DIS)
	{
		
	
		//電流表示
		tmp[0]=current_char[0];
		tmp[1]='.';
		tmp[2]=current_char[1];
		tmp[3]=current_char[2];
		tmp[4]='A';
		tmp[5]='\0';
		lcd_display(0xC0, tmp, 5);
		serial1_send_n(tmp, 4);
		serial1_send_n(", ", 2);

		//ad 電圧読み込み
		voltage_monitor = ad_read();
		
		//ad 電流読み込み
		current_monitor = ad_read_internal(3);
		c_tmp = current_monitor * 125 / 32;

		//容量更新
		capacity_monitor += current;

//表示
//電圧に変換
//アンプの倍率1/4
//x/(65536-1)*2.048*4
		v_tmp = voltage_monitor;
		tmp[0] = v_tmp / 4000;
		v_tmp = v_tmp % 4000;
		tmp[2] = v_tmp / 400;
		v_tmp = v_tmp % 400;
		tmp[3] = v_tmp / 40;
		v_tmp = v_tmp % 40;
		tmp[4] = v_tmp / 4;
		tmp[5] = convert_4to10[ v_tmp % 4 ];

		for(i=0;i<6;i++)
		{
		  tmp[i] += 48;
		}
		tmp[1] = '.';
		tmp[6] = 'V';
		tmp[7] = ' ';

		serial1_send_n(tmp, 6);
		serial1_send_n(", ", 2);
		
		
		//容量
		cap_tmp=capacity_monitor / 3 / 4096;
		tmp[8] = (cap_tmp / 1000) % 10+'0';
		tmp[9] = (cap_tmp / 100) % 10+'0';
		tmp[10] = (cap_tmp / 10) % 10+'0';
		tmp[11] = cap_tmp % 10+'0';
		tmp[12] = 'm';
		tmp[13] = 'A';
		tmp[14] = 'h';
		tmp[15] = ' ';
		lcd_display(0x80, tmp, 16);
		serial1_send_n(&tmp[8], 4);
		serial1_send_n(", ", 2);
		wait_50usec();

		//電流モニタ
		tmp[0] = c_tmp / 100 + '0';
		tmp[1] = '.';
		tmp[2] = (c_tmp / 10) % 10 + '0';
		tmp[3] = c_tmp % 10 + '0';
		tmp[4] = 'A';
		tmp[5] = '\0';
		
		lcd_display(0xC8, tmp, 8);
		serial1_send_n(tmp, 4);
		serial1_send_n(", \r\n", 4);
		

	
//		シリアル
//		終了判定
//			左ボタン

		if((sw_data & SW_LEFT) != 0)
		{
			serial1_send("msg: end@cancel\r\n");
			end_flag = 0b10000000;
			goto end_return;
		}else if(voltage_monitor <= voltage)
		{
			//絞り
			if(shibori == 0)
			{
				serial1_send("msg: end@volt\r\n");
				end_flag = 0b01000000;
				goto end_return;

			}else if(current <= stop_current)
			{
				serial1_send("msg: end@cur\r\n");
				end_flag = 0b00100000;
				goto end_return;
			}else
			{
/*					if(current >= 10)
					{
						current=current-10;
					}else{
						current=0;
					}
*/
					if(current > current - dec_speed-1)
					{
						current = current - dec_speed-1;
					}else{
						current = 0;
					}
					da_out(1, current);
					wait_50usec();
					current_to_current_char();
//					tmp[0]=current_char[0];
//					tmp[1]='.';
//					tmp[2]=current_char[1];
//					tmp[3]=current_char[2];
//					lcd_display(0xC0, tmp, 4);
//	wait_50usec();
					mode_shibori=1;
					
			}
		}else if((voltage_monitor>voltage) && (mode_shibori == 1))
		{
					current++;
//					current=current+10;
					da_out(1, current);
					wait_50usec();
					current_to_current_char();
//					tmp[0]=current_char[0];
//					tmp[1]='.';
//					tmp[2]=current_char[1];
//					tmp[3]=current_char[2];
//					lcd_display(0xC0, tmp, 4);
//	wait_50usec();
		}else if(capacity_monitor>=capacity)
		{
			serial1_send("end@cap\r\n");
			end_flag = 0b00010000;
			goto end_return;
		}




	}else if(mode == MODE_WAIT){
		serial1_send("\r\n");
		lcd_display(0x80, "WAIT", 16);
		lcd_display(0xC0, tmp, 16);
	}
	
	time_cnt ++;
	
	return;
	
end_return:
	edit_mode_off();
	da_out(0,0);
	da_out(1,0);
	mode = MODE_MENU;
	mode_shibori = 0;
	p2 = 0b00000000;
	asm("FCLR I");
	lcd_display(0xC0, "COMPLETE", 8);
	while(((sw_data & SW_LEFT) == 0) && (seq_mode == 0))
	{
		sw_data = check_sw();
	}
	
	return;

	
}

